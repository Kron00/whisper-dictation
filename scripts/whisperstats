#!/usr/bin/env python3
"""WhisperStats - Statistics dashboard for Whisper Dictation"""
import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')
from gi.repository import Gtk, Adw, GLib, Gio, Pango
import json
import sqlite3
from datetime import datetime, timedelta
from pathlib import Path
import os

STATS_DB = os.path.expanduser("~/.local/share/whisper-dictation/stats.db")
DICTIONARY_PATH = os.path.expanduser("~/.config/whisper-dictation/dictionary.json")

# Typing: 300 chars/min (60 WPM Ã— 5 chars/word standard)
# Speaking fallback: 142 WPM (measured from actual dictations)
TYPING_CPM = 300
SPEAKING_WPM = 142


def load_dictionary():
    try:
        with open(DICTIONARY_PATH) as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return []


def save_dictionary(entries):
    os.makedirs(os.path.dirname(DICTIONARY_PATH), exist_ok=True)
    with open(DICTIONARY_PATH, 'w') as f:
        json.dump(entries, f, indent=2)


class StatsWindow(Adw.ApplicationWindow):
    def __init__(self, app):
        super().__init__(application=app, title="WhisperStats")
        self.set_default_size(500, 700)

        # Main layout
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.set_content(main_box)

        # Header bar with ViewSwitcher
        header = Adw.HeaderBar()
        self.view_stack = Adw.ViewStack()
        switcher_title = Adw.ViewSwitcherTitle()
        switcher_title.set_stack(self.view_stack)
        header.set_title_widget(switcher_title)

        # Refresh button
        refresh_btn = Gtk.Button(icon_name="view-refresh-symbolic")
        refresh_btn.connect("clicked", lambda _: (self.refresh_stats(), self.refresh_dictionary()))
        refresh_btn.set_tooltip_text("Refresh")
        header.pack_end(refresh_btn)

        main_box.append(header)

        # ViewSwitcherBar for narrow widths
        switcher_bar = Adw.ViewSwitcherBar()
        switcher_bar.set_stack(self.view_stack)
        switcher_title.connect("notify::title-visible", lambda t, _: switcher_bar.set_reveal(t.get_title_visible()))

        # Stats page
        stats_page = self._build_stats_page()
        self.view_stack.add_titled_with_icon(stats_page, "stats", "Stats", "utilities-system-monitor-symbolic")

        # Dictionary page
        dict_page = self._build_dictionary_page()
        self.view_stack.add_titled_with_icon(dict_page, "dictionary", "Dictionary", "accessories-dictionary-symbolic")

        main_box.append(self.view_stack)
        main_box.append(switcher_bar)

        # Load initial data
        self.refresh_stats()
        self.refresh_dictionary()

        # Watch database for changes (instant updates on new dictations)
        self._refresh_pending = False
        self._change_received = False
        db_file = Gio.File.new_for_path(STATS_DB)
        self._db_monitor = db_file.monitor_file(Gio.FileMonitorFlags.NONE, None)
        self._db_monitor.connect("changed", self._on_db_changed)

        # Auto-refresh every 30 seconds as fallback
        GLib.timeout_add_seconds(30, self._auto_refresh)

    def _build_stats_page(self):
        scroll = Gtk.ScrolledWindow()
        scroll.set_vexpand(True)
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)

        content = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        content.set_margin_top(12)
        content.set_margin_bottom(12)
        content.set_margin_start(12)
        content.set_margin_end(12)
        scroll.set_child(content)

        self.cards = {}

        # Today's stats group
        today_group = Adw.PreferencesGroup(title="Today")
        content.append(today_group)

        self.cards['words_today'] = self._create_stat_row("Words Dictated", "0", "accessories-text-editor-symbolic")
        self.cards['dictations_today'] = self._create_stat_row("Dictations", "0", "audio-input-microphone-symbolic")
        self.cards['time_saved_today'] = self._create_stat_row("Time Saved", "0 min", "alarm-symbolic")
        today_group.add(self.cards['words_today'])
        today_group.add(self.cards['dictations_today'])
        today_group.add(self.cards['time_saved_today'])

        # All time stats group
        alltime_group = Adw.PreferencesGroup(title="All Time")
        content.append(alltime_group)

        self.cards['words_total'] = self._create_stat_row("Total Words", "0", "accessories-text-editor-symbolic")
        self.cards['dictations_total'] = self._create_stat_row("Total Dictations", "0", "audio-input-microphone-symbolic")
        self.cards['time_saved_total'] = self._create_stat_row("Total Time Saved", "0 min", "alarm-symbolic")
        self.cards['avg_words'] = self._create_stat_row("Avg Words/Dictation", "0", "dialog-information-symbolic")
        self.cards['speaking_wpm'] = self._create_stat_row("Your Speaking Rate", "0 WPM", "media-playback-start-symbolic")
        alltime_group.add(self.cards['words_total'])
        alltime_group.add(self.cards['dictations_total'])
        alltime_group.add(self.cards['time_saved_total'])
        alltime_group.add(self.cards['avg_words'])
        alltime_group.add(self.cards['speaking_wpm'])

        # This week stats
        week_group = Adw.PreferencesGroup(title="This Week")
        content.append(week_group)

        self.cards['words_week'] = self._create_stat_row("Words This Week", "0", "x-office-document-symbolic")
        self.cards['streak'] = self._create_stat_row("Active Days", "0 / 7", "emblem-ok-symbolic")
        week_group.add(self.cards['words_week'])
        week_group.add(self.cards['streak'])

        # Languages group
        lang_group = Adw.PreferencesGroup(title="Languages Detected")
        content.append(lang_group)

        self.lang_list = Gtk.ListBox()
        self.lang_list.set_selection_mode(Gtk.SelectionMode.NONE)
        self.lang_list.add_css_class("boxed-list")
        lang_group.add(self.lang_list)

        # Recent dictations group
        recent_group = Adw.PreferencesGroup(title="Recent Dictations")
        content.append(recent_group)

        self.recent_list = Gtk.ListBox()
        self.recent_list.set_selection_mode(Gtk.SelectionMode.NONE)
        self.recent_list.add_css_class("boxed-list")
        recent_group.add(self.recent_list)

        return scroll

    def _build_dictionary_page(self):
        scroll = Gtk.ScrolledWindow()
        scroll.set_vexpand(True)
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)

        content = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        content.set_margin_top(12)
        content.set_margin_bottom(12)
        content.set_margin_start(12)
        content.set_margin_end(12)
        scroll.set_child(content)

        # Dictionary group
        self.dict_group = Adw.PreferencesGroup(title="Custom Dictionary")
        self.dict_group.set_description("Words that Whisper often gets wrong. Replacements are applied after transcription.")
        content.append(self.dict_group)

        # Add button
        add_btn = Gtk.Button(label="Add Entry")
        add_btn.add_css_class("suggested-action")
        add_btn.add_css_class("pill")
        add_btn.set_halign(Gtk.Align.CENTER)
        add_btn.connect("clicked", self._on_add_entry)
        self.dict_group.add(add_btn)

        # List box for entries
        self.dict_list = Gtk.ListBox()
        self.dict_list.set_selection_mode(Gtk.SelectionMode.NONE)
        self.dict_list.add_css_class("boxed-list")
        self.dict_group.add(self.dict_list)

        # Empty state
        self.dict_empty = Adw.StatusPage()
        self.dict_empty.set_icon_name("accessories-dictionary-symbolic")
        self.dict_empty.set_title("No Dictionary Entries")
        self.dict_empty.set_description("Add words that Whisper often mistranscribes.")
        self.dict_empty.set_visible(False)
        content.append(self.dict_empty)

        return scroll

    def refresh_dictionary(self):
        # Clear existing rows
        while True:
            child = self.dict_list.get_first_child()
            if child is None:
                break
            self.dict_list.remove(child)

        entries = load_dictionary()

        if not entries:
            self.dict_list.set_visible(False)
            self.dict_empty.set_visible(True)
            return

        self.dict_list.set_visible(True)
        self.dict_empty.set_visible(False)

        for entry in entries:
            spoken = entry.get("spoken", "")
            replacement = entry.get("replacement", "")

            row = Adw.ActionRow()
            row.set_title(GLib.markup_escape_text(spoken))
            row.set_subtitle(GLib.markup_escape_text(f"\u2192 {replacement}"))
            row.add_prefix(Gtk.Image(icon_name="document-edit-symbolic"))

            delete_btn = Gtk.Button(icon_name="user-trash-symbolic")
            delete_btn.set_valign(Gtk.Align.CENTER)
            delete_btn.add_css_class("flat")
            delete_btn.add_css_class("error")
            delete_btn.connect("clicked", self._on_delete_entry, spoken)
            row.add_suffix(delete_btn)

            self.dict_list.append(row)

    def _on_add_entry(self, _btn):
        dialog = Adw.AlertDialog()
        dialog.set_heading("Add Dictionary Entry")
        dialog.set_body("Enter the spoken word and its replacement.")
        dialog.add_response("cancel", "Cancel")
        dialog.add_response("add", "Add")
        dialog.set_response_appearance("add", Adw.ResponseAppearance.SUGGESTED)
        dialog.set_default_response("add")
        dialog.set_close_response("cancel")

        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        box.set_margin_top(12)
        box.set_margin_start(12)
        box.set_margin_end(12)

        spoken_entry = Gtk.Entry()
        spoken_entry.set_placeholder_text("Spoken word (e.g. ghosty)")
        box.append(spoken_entry)

        replacement_entry = Gtk.Entry()
        replacement_entry.set_placeholder_text("Replacement (e.g. Gh0sty)")
        box.append(replacement_entry)

        dialog.set_extra_child(box)

        def on_response(d, response):
            if response == "add":
                spoken = spoken_entry.get_text().strip()
                replacement = replacement_entry.get_text().strip()
                if spoken and replacement:
                    entries = load_dictionary()
                    entries.append({"spoken": spoken, "replacement": replacement})
                    save_dictionary(entries)
                    self.refresh_dictionary()

        dialog.connect("response", on_response)
        dialog.present(self)

    def _on_delete_entry(self, _btn, spoken_word):
        entries = load_dictionary()
        entries = [e for e in entries if e.get("spoken") != spoken_word]
        save_dictionary(entries)
        self.refresh_dictionary()

    def _create_stat_row(self, title, value, icon_name):
        row = Adw.ActionRow(title=title)
        row.add_prefix(Gtk.Image(icon_name=icon_name))

        label = Gtk.Label(label=value)
        label.add_css_class("title-2")
        row.add_suffix(label)
        row._value_label = label

        return row

    def _on_db_changed(self, monitor, file, other_file, event_type):
        self._change_received = True
        if not self._refresh_pending:
            self._refresh_pending = True
            GLib.timeout_add(500, self._debounced_refresh)

    def _debounced_refresh(self):
        self._change_received = False
        self.refresh_stats()
        if self._change_received:
            # Events arrived during refresh, schedule another
            GLib.timeout_add(500, self._debounced_refresh)
        else:
            self._refresh_pending = False
        return False

    def _auto_refresh(self):
        self.refresh_stats()
        return True

    def refresh_stats(self):
        if not Path(STATS_DB).exists():
            return

        conn = None
        try:
            conn = sqlite3.connect(STATS_DB)
            cursor = conn.cursor()

            # Today's stats
            today = datetime.now().date().isoformat()
            cursor.execute(
                "SELECT COUNT(*), SUM(word_count) FROM dictations WHERE date(timestamp) = ?",
                (today,)
            )
            row = cursor.fetchone()
            dictations_today = row[0] or 0
            words_today = row[1] or 0

            self.cards['words_today']._value_label.set_text(f"{words_today:,}")
            self.cards['dictations_today']._value_label.set_text(str(dictations_today))

            # Time saved: use character count for typing time, split by audio tracking
            cursor.execute("""
                SELECT
                    SUM(CASE WHEN audio_duration_ms > 0 THEN LENGTH(text) ELSE 0 END),
                    SUM(CASE WHEN audio_duration_ms > 0 THEN audio_duration_ms ELSE 0 END),
                    SUM(CASE WHEN audio_duration_ms IS NULL OR audio_duration_ms = 0 THEN LENGTH(text) ELSE 0 END),
                    SUM(CASE WHEN audio_duration_ms IS NULL OR audio_duration_ms = 0 THEN word_count ELSE 0 END)
                FROM dictations WHERE date(timestamp) = ?
            """, (today,))
            row = cursor.fetchone()
            time_saved_today = self._calc_time_saved(row[0] or 0, row[1] or 0, row[2] or 0, row[3] or 0)
            self.cards['time_saved_today']._value_label.set_text(time_saved_today)

            # All time stats
            cursor.execute("SELECT COUNT(*), SUM(word_count) FROM dictations")
            row = cursor.fetchone()
            dictations_total = row[0] or 0
            words_total = row[1] or 0

            self.cards['words_total']._value_label.set_text(f"{words_total:,}")
            self.cards['dictations_total']._value_label.set_text(f"{dictations_total:,}")

            # Time saved: use character count for typing time, split by audio tracking
            cursor.execute("""
                SELECT
                    SUM(CASE WHEN audio_duration_ms > 0 THEN LENGTH(text) ELSE 0 END),
                    SUM(CASE WHEN audio_duration_ms > 0 THEN audio_duration_ms ELSE 0 END),
                    SUM(CASE WHEN audio_duration_ms IS NULL OR audio_duration_ms = 0 THEN LENGTH(text) ELSE 0 END),
                    SUM(CASE WHEN audio_duration_ms IS NULL OR audio_duration_ms = 0 THEN word_count ELSE 0 END)
                FROM dictations
            """)
            row = cursor.fetchone()
            time_saved_total = self._calc_time_saved(row[0] or 0, row[1] or 0, row[2] or 0, row[3] or 0)
            self.cards['time_saved_total']._value_label.set_text(time_saved_total)

            avg_words = words_total / dictations_total if dictations_total > 0 else 0
            self.cards['avg_words']._value_label.set_text(f"{avg_words:.1f}")

            # Calculate speaking WPM from audio duration
            cursor.execute("SELECT SUM(word_count), SUM(audio_duration_ms) FROM dictations WHERE audio_duration_ms > 0")
            row = cursor.fetchone()
            total_words_with_duration = row[0] or 0
            total_audio_ms = row[1] or 0
            if total_audio_ms > 0:
                speaking_wpm = (total_words_with_duration / (total_audio_ms / 60000))
                self.cards['speaking_wpm']._value_label.set_text(f"{speaking_wpm:.0f} WPM")
            else:
                self.cards['speaking_wpm']._value_label.set_text("-- WPM")

            # This week stats
            week_ago = (datetime.now() - timedelta(days=6)).date().isoformat()
            cursor.execute(
                "SELECT SUM(word_count) FROM dictations WHERE date(timestamp) >= ?",
                (week_ago,)
            )
            words_week = cursor.fetchone()[0] or 0
            self.cards['words_week']._value_label.set_text(f"{words_week:,}")

            # Active days this week
            cursor.execute(
                "SELECT COUNT(DISTINCT date(timestamp)) FROM dictations WHERE date(timestamp) >= ?",
                (week_ago,)
            )
            active_days = cursor.fetchone()[0] or 0
            self.cards['streak']._value_label.set_text(f"{active_days} / 7")

            # Languages
            cursor.execute(
                "SELECT language, COUNT(*) as cnt FROM dictations GROUP BY language ORDER BY cnt DESC LIMIT 5"
            )
            languages = cursor.fetchall()

            # Clear and rebuild language list
            while True:
                child = self.lang_list.get_first_child()
                if child is None:
                    break
                self.lang_list.remove(child)

            for lang, count in languages:
                lang_name = self._get_language_name(lang)
                row = Adw.ActionRow(title=lang_name, subtitle=f"{count} dictations")
                row.add_prefix(Gtk.Image(icon_name="preferences-desktop-locale-symbolic"))
                self.lang_list.append(row)

            # Recent dictations
            cursor.execute(
                "SELECT timestamp, text, word_count FROM dictations ORDER BY timestamp DESC LIMIT 10"
            )
            recent = cursor.fetchall()

            # Clear and rebuild recent list
            while True:
                child = self.recent_list.get_first_child()
                if child is None:
                    break
                self.recent_list.remove(child)

            for timestamp, text, word_count in recent:
                try:
                    dt = datetime.fromisoformat(timestamp)
                    time_str = dt.strftime("%H:%M")
                    date_str = dt.strftime("%b %d")
                except (ValueError, TypeError):
                    time_str = ""
                    date_str = ""

                display_text = text[:80] + "..." if len(text) > 80 else text

                row = Adw.ActionRow()
                row.set_title(GLib.markup_escape_text(display_text))
                row.set_subtitle(f"{date_str} {time_str} \u00b7 {word_count} words")
                self.recent_list.append(row)

        except Exception as e:
            print(f"Error loading stats: {e}")
        finally:
            if conn:
                conn.close()

    def _calc_time_saved(self, chars_with_audio, audio_ms, chars_without_audio, words_without_audio):
        total_chars = chars_with_audio + chars_without_audio
        if total_chars == 0:
            return "0 min"

        # Typing time: actual character count at 300 chars/min
        # Speaking time: actual audio duration (tracked) or word-based estimate (untracked)
        saved_tracked = (chars_with_audio / TYPING_CPM) - (audio_ms / 60000) if chars_with_audio > 0 else 0
        saved_untracked = (chars_without_audio / TYPING_CPM) - (words_without_audio / SPEAKING_WPM) if chars_without_audio > 0 else 0

        saved = max(0, saved_tracked + saved_untracked)

        if saved < 1:
            return f"{int(saved * 60)} sec"
        elif saved < 60:
            return f"{int(saved)} min"
        else:
            hours = int(saved // 60)
            mins = int(saved % 60)
            if mins == 0:
                return f"{hours}h"
            return f"{hours}h {mins}m"

    def _get_language_name(self, code):
        names = {
            "en": "English",
            "es": "Spanish",
            "fr": "French",
            "de": "German",
            "it": "Italian",
            "pt": "Portuguese",
            "ru": "Russian",
            "zh": "Chinese",
            "ja": "Japanese",
            "ko": "Korean",
            "ar": "Arabic",
            "hi": "Hindi",
            "nl": "Dutch",
            "pl": "Polish",
            "tr": "Turkish",
            "vi": "Vietnamese",
            "th": "Thai",
            "sv": "Swedish",
            "da": "Danish",
            "fi": "Finnish",
            "no": "Norwegian",
            "uk": "Ukrainian",
            "cs": "Czech",
            "el": "Greek",
            "he": "Hebrew",
            "id": "Indonesian",
            "ms": "Malay",
            "ro": "Romanian",
            "hu": "Hungarian",
        }
        return names.get(code, code.upper() if code else "Unknown")


class WhisperStatsApp(Adw.Application):
    def __init__(self):
        super().__init__(application_id="com.whisper.whisperstats")
        self.connect("activate", self.on_activate)

    def on_activate(self, app):
        win = StatsWindow(app)
        win.present()


if __name__ == "__main__":
    app = WhisperStatsApp()
    app.run()
